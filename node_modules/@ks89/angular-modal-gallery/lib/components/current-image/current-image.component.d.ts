import { AfterContentInit, ChangeDetectorRef, EventEmitter, NgZone, OnChanges, OnDestroy, OnInit, SimpleChanges } from '@angular/core';
import { AccessibleComponent } from '../accessible.component';
import { AccessibilityConfig } from '../../model/accessibility.interface';
import { Action } from '../../model/action.enum';
import { Image, ImageModalEvent } from '../../model/image.class';
import { InternalLibImage } from '../../model/image-internal.class';
import { KeyboardConfig } from '../../model/keyboard-config.interface';
import { SlideConfig } from '../../model/slide-config.interface';
import { CurrentImageConfig } from '../../model/current-image-config.interface';
/**
 * Interface to describe the Load Event, used to
 * emit an event when the image is finally loaded and the spinner has gone.
 */
import * as ɵngcc0 from '@angular/core';
export interface ImageLoadEvent {
    status: boolean;
    index: number;
    id: number;
}
/**
 * Component with the current image with some additional elements like arrows and side previews.
 */
export declare class CurrentImageComponent extends AccessibleComponent implements OnInit, OnChanges, AfterContentInit, OnDestroy {
    private _platformId;
    private _ngZone;
    private ref;
    /**
     * Unique id (>=0) of the current instance of this library. This is useful when you are using
     * the service to call modal gallery without open it manually.
     */
    id: number;
    /**
     * Object of type `InternalLibImage` that represent the visible image.
     */
    currentImage: InternalLibImage;
    /**
     * Array of `InternalLibImage` that represent the model of this library with all images,
     * thumbs and so on.
     */
    images: InternalLibImage[];
    /**
     * Boolean that it is true if the modal gallery is visible.
     * If yes, also this component should be visible.
     */
    isOpen: boolean;
    /**
     * Interface to configure current image in modal-gallery.
     * For instance you can disable navigation on click on current image (enabled by default).
     */
    currentImageConfig: CurrentImageConfig;
    /**
     * Object of type `SlideConfig` to get `infinite sliding`.
     */
    slideConfig: SlideConfig;
    /**
     * Object of type `AccessibilityConfig` to init custom accessibility features.
     * For instance, it contains titles, alt texts, aria-labels and so on.
     */
    accessibilityConfig: AccessibilityConfig;
    /**
     * Object of type `KeyboardConfig` to assign custom keys to both ESC, RIGHT and LEFT keyboard's actions.
     */
    keyboardConfig: KeyboardConfig;
    /**
     * Output to emit an event when images are loaded. The payload contains an `ImageLoadEvent`.
     */
    loadImage: EventEmitter<ImageLoadEvent>;
    /**
     * Output to emit any changes of the current image. The payload contains an `ImageModalEvent`.
     */
    changeImage: EventEmitter<ImageModalEvent>;
    /**
     * Output to emit an event when the modal gallery is closed. The payload contains an `ImageModalEvent`.
     */
    close: EventEmitter<ImageModalEvent>;
    /**
     * Subject to play modal-gallery.
     */
    private start$;
    /**
     * Subject to stop modal-gallery.
     */
    private stop$;
    /**
     * Enum of type `Action` that represents a normal action.
     * Declared here to be used inside the template.
     */
    normalAction: Action;
    /**
     * Enum of type `Action` that represents a mouse click on a button.
     * Declared here to be used inside the template.
     */
    clickAction: Action;
    /**
     * Enum of type `Action` that represents a keyboard action.
     * Declared here to be used inside the template.
     */
    keyboardAction: Action;
    /**
     * Boolean that it's true when you are watching the first image (currently visible).
     * False by default
     */
    isFirstImage: boolean;
    /**
     * Boolean that it's true when you are watching the last image (currently visible).
     * False by default
     */
    isLastImage: boolean;
    /**
     * Boolean that it's true if an image of the modal gallery is still loading.
     * True by default
     */
    loading: boolean;
    /**
     * Object of type `CurrentImageConfig` exposed to the template. This field is initialized
     * applying transformations, default values and so on to the input of the same type.
     */
    configCurrentImage: CurrentImageConfig;
    configSlide: SlideConfig;
    /**
     * Private object without type to define all swipe actions used by hammerjs.
     */
    private SWIPE_ACTION;
    constructor(_platformId: any, _ngZone: NgZone, ref: ChangeDetectorRef);
    /**
     * Listener to stop the gallery when the mouse pointer is over the current image.
     */
    onMouseEnter(): void;
    /**
     * Listener to play the gallery when the mouse pointer leave the current image.
     */
    onMouseLeave(): void;
    /**
     * Method ´ngOnInit´ to build `configCurrentImage` applying default values.
     * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
     * In particular, it's called only one time!!!
     */
    ngOnInit(): void;
    /**
     * Method ´ngOnChanges´ to update `loading` status and emit events.
     * If the gallery is open, then it will also manage boundary arrows and sliding.
     * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
     * In particular, it's called when any data-bound property of a directive changes!!!
     */
    ngOnChanges(changes: SimpleChanges): void;
    ngAfterContentInit(): void;
    /**
     * Method to handle keypress based on the `keyboardConfig` input. It gets the keyCode of
     * the key that triggered the keypress event to navigate between images or to close the modal gallery.
     * @param number keyCode of the key that triggered the keypress event
     */
    onKeyPress(keyCode: number): void;
    /**
     * Method to get the image description based on input params.
     * If you provide a full description this will be the visible description, otherwise,
     * it will be built using the `Description` object, concatenating its fields.
     * @param Image image to get its description. If not provided it will be the current image
     * @returns String description of the image (or the current image if not provided)
     * @throws an Error if description isn't available
     */
    getDescriptionToDisplay(image?: Image): string;
    /**
     * Method to get `alt attribute`.
     * `alt` specifies an alternate text for an image, if the image cannot be displayed.
     * @param Image image to get its alt description. If not provided it will be the current image
     * @returns String alt description of the image (or the current image if not provided)
     */
    getAltDescriptionByImage(image?: Image): string;
    /**
     * Method to get the title attributes based on descriptions.
     * This is useful to prevent accessibility issues, because if DescriptionStrategy is ALWAYS_HIDDEN,
     * it prevents an empty string as title.
     * @param Image image to get its description. If not provided it will be the current image
     * @returns String title of the image based on descriptions
     * @throws an Error if description isn't available
     */
    getTitleToDisplay(image?: Image): string;
    /**
     * Method to get the left side preview image.
     * @returns Image the image to show as size preview on the left
     */
    getLeftPreviewImage(): Image;
    /**
     * Method to get the right side preview image.
     * @returns Image the image to show as size preview on the right
     */
    getRightPreviewImage(): Image;
    /**
     * Method called by events from both keyboard and mouse on an image.
     * This will invoke the nextImage method.
     * @param KeyboardEvent | MouseEvent event payload
     * @param Action action that triggered the event or `Action.NORMAL` if not provided
     */
    onImageEvent(event: KeyboardEvent | MouseEvent, action?: Action): void;
    /**
     * Method called by events from both keyboard and mouse on a navigation arrow.
     * @param string direction of the navigation that can be either 'next' or 'prev'
     * @param KeyboardEvent | MouseEvent event payload
     * @param Action action that triggered the event or `Action.NORMAL` if not provided
     * @param boolean disable to disable navigation
     */
    onNavigationEvent(direction: string, event: KeyboardEvent, action?: Action, disable?: boolean): void;
    /**
     * Method to go back to the previous image.
     * @param action Enum of type `Action` that represents the source
     *  action that moved back to the previous image. `Action.NORMAL` by default.
     */
    prevImage(action?: Action): void;
    /**
     * Method to go back to the previous image.
     * @param action Enum of type `Action` that represents the source
     *  action that moved to the next image. `Action.NORMAL` by default.
     */
    nextImage(action?: Action): void;
    /**
     * Method to emit an event as loadImage output to say that the requested image if loaded.
     * This method is invoked by the javascript's 'load' event on an img tag.
     * @param Event event that triggered the load
     */
    onImageLoad(event: Event): void;
    /**
     * Method used by Hammerjs to support touch gestures (you can also invert the swipe direction with configCurrentImage.invertSwipe).
     * @param action String that represent the direction of the swipe action. 'swiperight' by default.
     */
    swipe(action?: string): void;
    /**
     * Method used in `modal-gallery.component` to get the index of an image to delete.
     * @param Image image to get the index, or the visible image, if not passed
     * @returns number the index of the image
     */
    getIndexToDelete(image?: Image): number;
    /**
     * Method to play modal gallery.
     */
    playCarousel(): void;
    /**
     * Stops modal gallery from cycling through items.
     */
    stopCarousel(): void;
    /**
     * Method to cleanup resources. In fact, this will stop the modal gallery.
     * This is an Angular's lifecycle hook that is called when this component is destroyed.
     */
    ngOnDestroy(): void;
    /**
     * Private method to update both `isFirstImage` and `isLastImage` based on
     * the index of the current image.
     * @param number currentIndex is the index of the current image
     */
    private handleBoundaries;
    /**
     * Private method to check if next/prev actions should be blocked.
     * It checks if configSlide.infinite === false and if the image index is equals to the input parameter.
     * If yes, it returns true to say that sliding should be blocked, otherwise not.
     * @param number boundaryIndex that could be either the beginning index (0) or the last index
     *  of images (this.images.length - 1).
     * @returns boolean true if configSlide.infinite === false and the current index is
     *  either the first or the last one.
     */
    private isPreventSliding;
    /**
     * Private method to get the next index.
     * This is necessary because at the end, when you call next again, you'll go to the first image.
     * That happens because all modal images are shown like in a circle.
     */
    private getNextImage;
    /**
     * Private method to get the previous index.
     * This is necessary because at index 0, when you call prev again, you'll go to the last image.
     * That happens because all modal images are shown like in a circle.
     */
    private getPrevImage;
    /**
     * Private method to build a text description.
     * This is used also to create titles.
     * @param Image image to get its description. If not provided it will be the current image.
     * @param boolean imageWithoutDescription is a boolean that it's true if the image hasn't a 'modal' description.
     * @returns String description built concatenating image fields with a specific logic.
     */
    private buildTextDescription;
    /**
     * Private method to call handleBoundaries when ngOnChanges is called.
     */
    private updateIndexes;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CurrentImageComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<CurrentImageComponent, "ks-current-image", never, { "id": "id"; "currentImage": "currentImage"; "images": "images"; "isOpen": "isOpen"; "currentImageConfig": "currentImageConfig"; "slideConfig": "slideConfig"; "accessibilityConfig": "accessibilityConfig"; "keyboardConfig": "keyboardConfig"; }, { "loadImage": "loadImage"; "changeImage": "changeImage"; "close": "close"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3VycmVudC1pbWFnZS5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsiY3VycmVudC1pbWFnZS5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4UUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDaGFuZ2VEZXRlY3RvclJlZiwgRXZlbnRFbWl0dGVyLCBOZ1pvbmUsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFjY2Vzc2libGVDb21wb25lbnQgfSBmcm9tICcuLi9hY2Nlc3NpYmxlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBBY2Nlc3NpYmlsaXR5Q29uZmlnIH0gZnJvbSAnLi4vLi4vbW9kZWwvYWNjZXNzaWJpbGl0eS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi4vLi4vbW9kZWwvYWN0aW9uLmVudW0nO1xuaW1wb3J0IHsgSW1hZ2UsIEltYWdlTW9kYWxFdmVudCB9IGZyb20gJy4uLy4uL21vZGVsL2ltYWdlLmNsYXNzJztcbmltcG9ydCB7IEludGVybmFsTGliSW1hZ2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pbWFnZS1pbnRlcm5hbC5jbGFzcyc7XG5pbXBvcnQgeyBLZXlib2FyZENvbmZpZyB9IGZyb20gJy4uLy4uL21vZGVsL2tleWJvYXJkLWNvbmZpZy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2xpZGVDb25maWcgfSBmcm9tICcuLi8uLi9tb2RlbC9zbGlkZS1jb25maWcuaW50ZXJmYWNlJztcbmltcG9ydCB7IEN1cnJlbnRJbWFnZUNvbmZpZyB9IGZyb20gJy4uLy4uL21vZGVsL2N1cnJlbnQtaW1hZ2UtY29uZmlnLmludGVyZmFjZSc7XG4vKipcbiAqIEludGVyZmFjZSB0byBkZXNjcmliZSB0aGUgTG9hZCBFdmVudCwgdXNlZCB0b1xuICogZW1pdCBhbiBldmVudCB3aGVuIHRoZSBpbWFnZSBpcyBmaW5hbGx5IGxvYWRlZCBhbmQgdGhlIHNwaW5uZXIgaGFzIGdvbmUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VMb2FkRXZlbnQge1xuICAgIHN0YXR1czogYm9vbGVhbjtcbiAgICBpbmRleDogbnVtYmVyO1xuICAgIGlkOiBudW1iZXI7XG59XG4vKipcbiAqIENvbXBvbmVudCB3aXRoIHRoZSBjdXJyZW50IGltYWdlIHdpdGggc29tZSBhZGRpdGlvbmFsIGVsZW1lbnRzIGxpa2UgYXJyb3dzIGFuZCBzaWRlIHByZXZpZXdzLlxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBDdXJyZW50SW1hZ2VDb21wb25lbnQgZXh0ZW5kcyBBY2Nlc3NpYmxlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBfcGxhdGZvcm1JZDtcbiAgICBwcml2YXRlIF9uZ1pvbmU7XG4gICAgcHJpdmF0ZSByZWY7XG4gICAgLyoqXG4gICAgICogVW5pcXVlIGlkICg+PTApIG9mIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoaXMgbGlicmFyeS4gVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3UgYXJlIHVzaW5nXG4gICAgICogdGhlIHNlcnZpY2UgdG8gY2FsbCBtb2RhbCBnYWxsZXJ5IHdpdGhvdXQgb3BlbiBpdCBtYW51YWxseS5cbiAgICAgKi9cbiAgICBpZDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIE9iamVjdCBvZiB0eXBlIGBJbnRlcm5hbExpYkltYWdlYCB0aGF0IHJlcHJlc2VudCB0aGUgdmlzaWJsZSBpbWFnZS5cbiAgICAgKi9cbiAgICBjdXJyZW50SW1hZ2U6IEludGVybmFsTGliSW1hZ2U7XG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgYEludGVybmFsTGliSW1hZ2VgIHRoYXQgcmVwcmVzZW50IHRoZSBtb2RlbCBvZiB0aGlzIGxpYnJhcnkgd2l0aCBhbGwgaW1hZ2VzLFxuICAgICAqIHRodW1icyBhbmQgc28gb24uXG4gICAgICovXG4gICAgaW1hZ2VzOiBJbnRlcm5hbExpYkltYWdlW107XG4gICAgLyoqXG4gICAgICogQm9vbGVhbiB0aGF0IGl0IGlzIHRydWUgaWYgdGhlIG1vZGFsIGdhbGxlcnkgaXMgdmlzaWJsZS5cbiAgICAgKiBJZiB5ZXMsIGFsc28gdGhpcyBjb21wb25lbnQgc2hvdWxkIGJlIHZpc2libGUuXG4gICAgICovXG4gICAgaXNPcGVuOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEludGVyZmFjZSB0byBjb25maWd1cmUgY3VycmVudCBpbWFnZSBpbiBtb2RhbC1nYWxsZXJ5LlxuICAgICAqIEZvciBpbnN0YW5jZSB5b3UgY2FuIGRpc2FibGUgbmF2aWdhdGlvbiBvbiBjbGljayBvbiBjdXJyZW50IGltYWdlIChlbmFibGVkIGJ5IGRlZmF1bHQpLlxuICAgICAqL1xuICAgIGN1cnJlbnRJbWFnZUNvbmZpZzogQ3VycmVudEltYWdlQ29uZmlnO1xuICAgIC8qKlxuICAgICAqIE9iamVjdCBvZiB0eXBlIGBTbGlkZUNvbmZpZ2AgdG8gZ2V0IGBpbmZpbml0ZSBzbGlkaW5nYC5cbiAgICAgKi9cbiAgICBzbGlkZUNvbmZpZzogU2xpZGVDb25maWc7XG4gICAgLyoqXG4gICAgICogT2JqZWN0IG9mIHR5cGUgYEFjY2Vzc2liaWxpdHlDb25maWdgIHRvIGluaXQgY3VzdG9tIGFjY2Vzc2liaWxpdHkgZmVhdHVyZXMuXG4gICAgICogRm9yIGluc3RhbmNlLCBpdCBjb250YWlucyB0aXRsZXMsIGFsdCB0ZXh0cywgYXJpYS1sYWJlbHMgYW5kIHNvIG9uLlxuICAgICAqL1xuICAgIGFjY2Vzc2liaWxpdHlDb25maWc6IEFjY2Vzc2liaWxpdHlDb25maWc7XG4gICAgLyoqXG4gICAgICogT2JqZWN0IG9mIHR5cGUgYEtleWJvYXJkQ29uZmlnYCB0byBhc3NpZ24gY3VzdG9tIGtleXMgdG8gYm90aCBFU0MsIFJJR0hUIGFuZCBMRUZUIGtleWJvYXJkJ3MgYWN0aW9ucy5cbiAgICAgKi9cbiAgICBrZXlib2FyZENvbmZpZzogS2V5Ym9hcmRDb25maWc7XG4gICAgLyoqXG4gICAgICogT3V0cHV0IHRvIGVtaXQgYW4gZXZlbnQgd2hlbiBpbWFnZXMgYXJlIGxvYWRlZC4gVGhlIHBheWxvYWQgY29udGFpbnMgYW4gYEltYWdlTG9hZEV2ZW50YC5cbiAgICAgKi9cbiAgICBsb2FkSW1hZ2U6IEV2ZW50RW1pdHRlcjxJbWFnZUxvYWRFdmVudD47XG4gICAgLyoqXG4gICAgICogT3V0cHV0IHRvIGVtaXQgYW55IGNoYW5nZXMgb2YgdGhlIGN1cnJlbnQgaW1hZ2UuIFRoZSBwYXlsb2FkIGNvbnRhaW5zIGFuIGBJbWFnZU1vZGFsRXZlbnRgLlxuICAgICAqL1xuICAgIGNoYW5nZUltYWdlOiBFdmVudEVtaXR0ZXI8SW1hZ2VNb2RhbEV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBPdXRwdXQgdG8gZW1pdCBhbiBldmVudCB3aGVuIHRoZSBtb2RhbCBnYWxsZXJ5IGlzIGNsb3NlZC4gVGhlIHBheWxvYWQgY29udGFpbnMgYW4gYEltYWdlTW9kYWxFdmVudGAuXG4gICAgICovXG4gICAgY2xvc2U6IEV2ZW50RW1pdHRlcjxJbWFnZU1vZGFsRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIFN1YmplY3QgdG8gcGxheSBtb2RhbC1nYWxsZXJ5LlxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhcnQkO1xuICAgIC8qKlxuICAgICAqIFN1YmplY3QgdG8gc3RvcCBtb2RhbC1nYWxsZXJ5LlxuICAgICAqL1xuICAgIHByaXZhdGUgc3RvcCQ7XG4gICAgLyoqXG4gICAgICogRW51bSBvZiB0eXBlIGBBY3Rpb25gIHRoYXQgcmVwcmVzZW50cyBhIG5vcm1hbCBhY3Rpb24uXG4gICAgICogRGVjbGFyZWQgaGVyZSB0byBiZSB1c2VkIGluc2lkZSB0aGUgdGVtcGxhdGUuXG4gICAgICovXG4gICAgbm9ybWFsQWN0aW9uOiBBY3Rpb247XG4gICAgLyoqXG4gICAgICogRW51bSBvZiB0eXBlIGBBY3Rpb25gIHRoYXQgcmVwcmVzZW50cyBhIG1vdXNlIGNsaWNrIG9uIGEgYnV0dG9uLlxuICAgICAqIERlY2xhcmVkIGhlcmUgdG8gYmUgdXNlZCBpbnNpZGUgdGhlIHRlbXBsYXRlLlxuICAgICAqL1xuICAgIGNsaWNrQWN0aW9uOiBBY3Rpb247XG4gICAgLyoqXG4gICAgICogRW51bSBvZiB0eXBlIGBBY3Rpb25gIHRoYXQgcmVwcmVzZW50cyBhIGtleWJvYXJkIGFjdGlvbi5cbiAgICAgKiBEZWNsYXJlZCBoZXJlIHRvIGJlIHVzZWQgaW5zaWRlIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKi9cbiAgICBrZXlib2FyZEFjdGlvbjogQWN0aW9uO1xuICAgIC8qKlxuICAgICAqIEJvb2xlYW4gdGhhdCBpdCdzIHRydWUgd2hlbiB5b3UgYXJlIHdhdGNoaW5nIHRoZSBmaXJzdCBpbWFnZSAoY3VycmVudGx5IHZpc2libGUpLlxuICAgICAqIEZhbHNlIGJ5IGRlZmF1bHRcbiAgICAgKi9cbiAgICBpc0ZpcnN0SW1hZ2U6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQm9vbGVhbiB0aGF0IGl0J3MgdHJ1ZSB3aGVuIHlvdSBhcmUgd2F0Y2hpbmcgdGhlIGxhc3QgaW1hZ2UgKGN1cnJlbnRseSB2aXNpYmxlKS5cbiAgICAgKiBGYWxzZSBieSBkZWZhdWx0XG4gICAgICovXG4gICAgaXNMYXN0SW1hZ2U6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQm9vbGVhbiB0aGF0IGl0J3MgdHJ1ZSBpZiBhbiBpbWFnZSBvZiB0aGUgbW9kYWwgZ2FsbGVyeSBpcyBzdGlsbCBsb2FkaW5nLlxuICAgICAqIFRydWUgYnkgZGVmYXVsdFxuICAgICAqL1xuICAgIGxvYWRpbmc6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogT2JqZWN0IG9mIHR5cGUgYEN1cnJlbnRJbWFnZUNvbmZpZ2AgZXhwb3NlZCB0byB0aGUgdGVtcGxhdGUuIFRoaXMgZmllbGQgaXMgaW5pdGlhbGl6ZWRcbiAgICAgKiBhcHBseWluZyB0cmFuc2Zvcm1hdGlvbnMsIGRlZmF1bHQgdmFsdWVzIGFuZCBzbyBvbiB0byB0aGUgaW5wdXQgb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAgKi9cbiAgICBjb25maWdDdXJyZW50SW1hZ2U6IEN1cnJlbnRJbWFnZUNvbmZpZztcbiAgICBjb25maWdTbGlkZTogU2xpZGVDb25maWc7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBvYmplY3Qgd2l0aG91dCB0eXBlIHRvIGRlZmluZSBhbGwgc3dpcGUgYWN0aW9ucyB1c2VkIGJ5IGhhbW1lcmpzLlxuICAgICAqL1xuICAgIHByaXZhdGUgU1dJUEVfQUNUSU9OO1xuICAgIGNvbnN0cnVjdG9yKF9wbGF0Zm9ybUlkOiBhbnksIF9uZ1pvbmU6IE5nWm9uZSwgcmVmOiBDaGFuZ2VEZXRlY3RvclJlZik7XG4gICAgLyoqXG4gICAgICogTGlzdGVuZXIgdG8gc3RvcCB0aGUgZ2FsbGVyeSB3aGVuIHRoZSBtb3VzZSBwb2ludGVyIGlzIG92ZXIgdGhlIGN1cnJlbnQgaW1hZ2UuXG4gICAgICovXG4gICAgb25Nb3VzZUVudGVyKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTGlzdGVuZXIgdG8gcGxheSB0aGUgZ2FsbGVyeSB3aGVuIHRoZSBtb3VzZSBwb2ludGVyIGxlYXZlIHRoZSBjdXJyZW50IGltYWdlLlxuICAgICAqL1xuICAgIG9uTW91c2VMZWF2ZSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCDCtG5nT25Jbml0wrQgdG8gYnVpbGQgYGNvbmZpZ0N1cnJlbnRJbWFnZWAgYXBwbHlpbmcgZGVmYXVsdCB2YWx1ZXMuXG4gICAgICogVGhpcyBpcyBhbiBBbmd1bGFyJ3MgbGlmZWN5Y2xlIGhvb2ssIHNvIGl0cyBjYWxsZWQgYXV0b21hdGljYWxseSBieSBBbmd1bGFyIGl0c2VsZi5cbiAgICAgKiBJbiBwYXJ0aWN1bGFyLCBpdCdzIGNhbGxlZCBvbmx5IG9uZSB0aW1lISEhXG4gICAgICovXG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgwrRuZ09uQ2hhbmdlc8K0IHRvIHVwZGF0ZSBgbG9hZGluZ2Agc3RhdHVzIGFuZCBlbWl0IGV2ZW50cy5cbiAgICAgKiBJZiB0aGUgZ2FsbGVyeSBpcyBvcGVuLCB0aGVuIGl0IHdpbGwgYWxzbyBtYW5hZ2UgYm91bmRhcnkgYXJyb3dzIGFuZCBzbGlkaW5nLlxuICAgICAqIFRoaXMgaXMgYW4gQW5ndWxhcidzIGxpZmVjeWNsZSBob29rLCBzbyBpdHMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgQW5ndWxhciBpdHNlbGYuXG4gICAgICogSW4gcGFydGljdWxhciwgaXQncyBjYWxsZWQgd2hlbiBhbnkgZGF0YS1ib3VuZCBwcm9wZXJ0eSBvZiBhIGRpcmVjdGl2ZSBjaGFuZ2VzISEhXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQ7XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGhhbmRsZSBrZXlwcmVzcyBiYXNlZCBvbiB0aGUgYGtleWJvYXJkQ29uZmlnYCBpbnB1dC4gSXQgZ2V0cyB0aGUga2V5Q29kZSBvZlxuICAgICAqIHRoZSBrZXkgdGhhdCB0cmlnZ2VyZWQgdGhlIGtleXByZXNzIGV2ZW50IHRvIG5hdmlnYXRlIGJldHdlZW4gaW1hZ2VzIG9yIHRvIGNsb3NlIHRoZSBtb2RhbCBnYWxsZXJ5LlxuICAgICAqIEBwYXJhbSBudW1iZXIga2V5Q29kZSBvZiB0aGUga2V5IHRoYXQgdHJpZ2dlcmVkIHRoZSBrZXlwcmVzcyBldmVudFxuICAgICAqL1xuICAgIG9uS2V5UHJlc3Moa2V5Q29kZTogbnVtYmVyKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gZ2V0IHRoZSBpbWFnZSBkZXNjcmlwdGlvbiBiYXNlZCBvbiBpbnB1dCBwYXJhbXMuXG4gICAgICogSWYgeW91IHByb3ZpZGUgYSBmdWxsIGRlc2NyaXB0aW9uIHRoaXMgd2lsbCBiZSB0aGUgdmlzaWJsZSBkZXNjcmlwdGlvbiwgb3RoZXJ3aXNlLFxuICAgICAqIGl0IHdpbGwgYmUgYnVpbHQgdXNpbmcgdGhlIGBEZXNjcmlwdGlvbmAgb2JqZWN0LCBjb25jYXRlbmF0aW5nIGl0cyBmaWVsZHMuXG4gICAgICogQHBhcmFtIEltYWdlIGltYWdlIHRvIGdldCBpdHMgZGVzY3JpcHRpb24uIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIHRoZSBjdXJyZW50IGltYWdlXG4gICAgICogQHJldHVybnMgU3RyaW5nIGRlc2NyaXB0aW9uIG9mIHRoZSBpbWFnZSAob3IgdGhlIGN1cnJlbnQgaW1hZ2UgaWYgbm90IHByb3ZpZGVkKVxuICAgICAqIEB0aHJvd3MgYW4gRXJyb3IgaWYgZGVzY3JpcHRpb24gaXNuJ3QgYXZhaWxhYmxlXG4gICAgICovXG4gICAgZ2V0RGVzY3JpcHRpb25Ub0Rpc3BsYXkoaW1hZ2U/OiBJbWFnZSk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gZ2V0IGBhbHQgYXR0cmlidXRlYC5cbiAgICAgKiBgYWx0YCBzcGVjaWZpZXMgYW4gYWx0ZXJuYXRlIHRleHQgZm9yIGFuIGltYWdlLCBpZiB0aGUgaW1hZ2UgY2Fubm90IGJlIGRpc3BsYXllZC5cbiAgICAgKiBAcGFyYW0gSW1hZ2UgaW1hZ2UgdG8gZ2V0IGl0cyBhbHQgZGVzY3JpcHRpb24uIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIHRoZSBjdXJyZW50IGltYWdlXG4gICAgICogQHJldHVybnMgU3RyaW5nIGFsdCBkZXNjcmlwdGlvbiBvZiB0aGUgaW1hZ2UgKG9yIHRoZSBjdXJyZW50IGltYWdlIGlmIG5vdCBwcm92aWRlZClcbiAgICAgKi9cbiAgICBnZXRBbHREZXNjcmlwdGlvbkJ5SW1hZ2UoaW1hZ2U/OiBJbWFnZSk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gZ2V0IHRoZSB0aXRsZSBhdHRyaWJ1dGVzIGJhc2VkIG9uIGRlc2NyaXB0aW9ucy5cbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCB0byBwcmV2ZW50IGFjY2Vzc2liaWxpdHkgaXNzdWVzLCBiZWNhdXNlIGlmIERlc2NyaXB0aW9uU3RyYXRlZ3kgaXMgQUxXQVlTX0hJRERFTixcbiAgICAgKiBpdCBwcmV2ZW50cyBhbiBlbXB0eSBzdHJpbmcgYXMgdGl0bGUuXG4gICAgICogQHBhcmFtIEltYWdlIGltYWdlIHRvIGdldCBpdHMgZGVzY3JpcHRpb24uIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIHRoZSBjdXJyZW50IGltYWdlXG4gICAgICogQHJldHVybnMgU3RyaW5nIHRpdGxlIG9mIHRoZSBpbWFnZSBiYXNlZCBvbiBkZXNjcmlwdGlvbnNcbiAgICAgKiBAdGhyb3dzIGFuIEVycm9yIGlmIGRlc2NyaXB0aW9uIGlzbid0IGF2YWlsYWJsZVxuICAgICAqL1xuICAgIGdldFRpdGxlVG9EaXNwbGF5KGltYWdlPzogSW1hZ2UpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGdldCB0aGUgbGVmdCBzaWRlIHByZXZpZXcgaW1hZ2UuXG4gICAgICogQHJldHVybnMgSW1hZ2UgdGhlIGltYWdlIHRvIHNob3cgYXMgc2l6ZSBwcmV2aWV3IG9uIHRoZSBsZWZ0XG4gICAgICovXG4gICAgZ2V0TGVmdFByZXZpZXdJbWFnZSgpOiBJbWFnZTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gZ2V0IHRoZSByaWdodCBzaWRlIHByZXZpZXcgaW1hZ2UuXG4gICAgICogQHJldHVybnMgSW1hZ2UgdGhlIGltYWdlIHRvIHNob3cgYXMgc2l6ZSBwcmV2aWV3IG9uIHRoZSByaWdodFxuICAgICAqL1xuICAgIGdldFJpZ2h0UHJldmlld0ltYWdlKCk6IEltYWdlO1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCBjYWxsZWQgYnkgZXZlbnRzIGZyb20gYm90aCBrZXlib2FyZCBhbmQgbW91c2Ugb24gYW4gaW1hZ2UuXG4gICAgICogVGhpcyB3aWxsIGludm9rZSB0aGUgbmV4dEltYWdlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gS2V5Ym9hcmRFdmVudCB8IE1vdXNlRXZlbnQgZXZlbnQgcGF5bG9hZFxuICAgICAqIEBwYXJhbSBBY3Rpb24gYWN0aW9uIHRoYXQgdHJpZ2dlcmVkIHRoZSBldmVudCBvciBgQWN0aW9uLk5PUk1BTGAgaWYgbm90IHByb3ZpZGVkXG4gICAgICovXG4gICAgb25JbWFnZUV2ZW50KGV2ZW50OiBLZXlib2FyZEV2ZW50IHwgTW91c2VFdmVudCwgYWN0aW9uPzogQWN0aW9uKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgY2FsbGVkIGJ5IGV2ZW50cyBmcm9tIGJvdGgga2V5Ym9hcmQgYW5kIG1vdXNlIG9uIGEgbmF2aWdhdGlvbiBhcnJvdy5cbiAgICAgKiBAcGFyYW0gc3RyaW5nIGRpcmVjdGlvbiBvZiB0aGUgbmF2aWdhdGlvbiB0aGF0IGNhbiBiZSBlaXRoZXIgJ25leHQnIG9yICdwcmV2J1xuICAgICAqIEBwYXJhbSBLZXlib2FyZEV2ZW50IHwgTW91c2VFdmVudCBldmVudCBwYXlsb2FkXG4gICAgICogQHBhcmFtIEFjdGlvbiBhY3Rpb24gdGhhdCB0cmlnZ2VyZWQgdGhlIGV2ZW50IG9yIGBBY3Rpb24uTk9STUFMYCBpZiBub3QgcHJvdmlkZWRcbiAgICAgKiBAcGFyYW0gYm9vbGVhbiBkaXNhYmxlIHRvIGRpc2FibGUgbmF2aWdhdGlvblxuICAgICAqL1xuICAgIG9uTmF2aWdhdGlvbkV2ZW50KGRpcmVjdGlvbjogc3RyaW5nLCBldmVudDogS2V5Ym9hcmRFdmVudCwgYWN0aW9uPzogQWN0aW9uLCBkaXNhYmxlPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGdvIGJhY2sgdG8gdGhlIHByZXZpb3VzIGltYWdlLlxuICAgICAqIEBwYXJhbSBhY3Rpb24gRW51bSBvZiB0eXBlIGBBY3Rpb25gIHRoYXQgcmVwcmVzZW50cyB0aGUgc291cmNlXG4gICAgICogIGFjdGlvbiB0aGF0IG1vdmVkIGJhY2sgdG8gdGhlIHByZXZpb3VzIGltYWdlLiBgQWN0aW9uLk5PUk1BTGAgYnkgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBwcmV2SW1hZ2UoYWN0aW9uPzogQWN0aW9uKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gZ28gYmFjayB0byB0aGUgcHJldmlvdXMgaW1hZ2UuXG4gICAgICogQHBhcmFtIGFjdGlvbiBFbnVtIG9mIHR5cGUgYEFjdGlvbmAgdGhhdCByZXByZXNlbnRzIHRoZSBzb3VyY2VcbiAgICAgKiAgYWN0aW9uIHRoYXQgbW92ZWQgdG8gdGhlIG5leHQgaW1hZ2UuIGBBY3Rpb24uTk9STUFMYCBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIG5leHRJbWFnZShhY3Rpb24/OiBBY3Rpb24pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBlbWl0IGFuIGV2ZW50IGFzIGxvYWRJbWFnZSBvdXRwdXQgdG8gc2F5IHRoYXQgdGhlIHJlcXVlc3RlZCBpbWFnZSBpZiBsb2FkZWQuXG4gICAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBieSB0aGUgamF2YXNjcmlwdCdzICdsb2FkJyBldmVudCBvbiBhbiBpbWcgdGFnLlxuICAgICAqIEBwYXJhbSBFdmVudCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGUgbG9hZFxuICAgICAqL1xuICAgIG9uSW1hZ2VMb2FkKGV2ZW50OiBFdmVudCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgYnkgSGFtbWVyanMgdG8gc3VwcG9ydCB0b3VjaCBnZXN0dXJlcyAoeW91IGNhbiBhbHNvIGludmVydCB0aGUgc3dpcGUgZGlyZWN0aW9uIHdpdGggY29uZmlnQ3VycmVudEltYWdlLmludmVydFN3aXBlKS5cbiAgICAgKiBAcGFyYW0gYWN0aW9uIFN0cmluZyB0aGF0IHJlcHJlc2VudCB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzd2lwZSBhY3Rpb24uICdzd2lwZXJpZ2h0JyBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIHN3aXBlKGFjdGlvbj86IHN0cmluZyk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgaW4gYG1vZGFsLWdhbGxlcnkuY29tcG9uZW50YCB0byBnZXQgdGhlIGluZGV4IG9mIGFuIGltYWdlIHRvIGRlbGV0ZS5cbiAgICAgKiBAcGFyYW0gSW1hZ2UgaW1hZ2UgdG8gZ2V0IHRoZSBpbmRleCwgb3IgdGhlIHZpc2libGUgaW1hZ2UsIGlmIG5vdCBwYXNzZWRcbiAgICAgKiBAcmV0dXJucyBudW1iZXIgdGhlIGluZGV4IG9mIHRoZSBpbWFnZVxuICAgICAqL1xuICAgIGdldEluZGV4VG9EZWxldGUoaW1hZ2U/OiBJbWFnZSk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gcGxheSBtb2RhbCBnYWxsZXJ5LlxuICAgICAqL1xuICAgIHBsYXlDYXJvdXNlbCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFN0b3BzIG1vZGFsIGdhbGxlcnkgZnJvbSBjeWNsaW5nIHRocm91Z2ggaXRlbXMuXG4gICAgICovXG4gICAgc3RvcENhcm91c2VsKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGNsZWFudXAgcmVzb3VyY2VzLiBJbiBmYWN0LCB0aGlzIHdpbGwgc3RvcCB0aGUgbW9kYWwgZ2FsbGVyeS5cbiAgICAgKiBUaGlzIGlzIGFuIEFuZ3VsYXIncyBsaWZlY3ljbGUgaG9vayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGlzIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFByaXZhdGUgbWV0aG9kIHRvIHVwZGF0ZSBib3RoIGBpc0ZpcnN0SW1hZ2VgIGFuZCBgaXNMYXN0SW1hZ2VgIGJhc2VkIG9uXG4gICAgICogdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGltYWdlLlxuICAgICAqIEBwYXJhbSBudW1iZXIgY3VycmVudEluZGV4IGlzIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBpbWFnZVxuICAgICAqL1xuICAgIHByaXZhdGUgaGFuZGxlQm91bmRhcmllcztcbiAgICAvKipcbiAgICAgKiBQcml2YXRlIG1ldGhvZCB0byBjaGVjayBpZiBuZXh0L3ByZXYgYWN0aW9ucyBzaG91bGQgYmUgYmxvY2tlZC5cbiAgICAgKiBJdCBjaGVja3MgaWYgY29uZmlnU2xpZGUuaW5maW5pdGUgPT09IGZhbHNlIGFuZCBpZiB0aGUgaW1hZ2UgaW5kZXggaXMgZXF1YWxzIHRvIHRoZSBpbnB1dCBwYXJhbWV0ZXIuXG4gICAgICogSWYgeWVzLCBpdCByZXR1cm5zIHRydWUgdG8gc2F5IHRoYXQgc2xpZGluZyBzaG91bGQgYmUgYmxvY2tlZCwgb3RoZXJ3aXNlIG5vdC5cbiAgICAgKiBAcGFyYW0gbnVtYmVyIGJvdW5kYXJ5SW5kZXggdGhhdCBjb3VsZCBiZSBlaXRoZXIgdGhlIGJlZ2lubmluZyBpbmRleCAoMCkgb3IgdGhlIGxhc3QgaW5kZXhcbiAgICAgKiAgb2YgaW1hZ2VzICh0aGlzLmltYWdlcy5sZW5ndGggLSAxKS5cbiAgICAgKiBAcmV0dXJucyBib29sZWFuIHRydWUgaWYgY29uZmlnU2xpZGUuaW5maW5pdGUgPT09IGZhbHNlIGFuZCB0aGUgY3VycmVudCBpbmRleCBpc1xuICAgICAqICBlaXRoZXIgdGhlIGZpcnN0IG9yIHRoZSBsYXN0IG9uZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGlzUHJldmVudFNsaWRpbmc7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgdG8gZ2V0IHRoZSBuZXh0IGluZGV4LlxuICAgICAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYXQgdGhlIGVuZCwgd2hlbiB5b3UgY2FsbCBuZXh0IGFnYWluLCB5b3UnbGwgZ28gdG8gdGhlIGZpcnN0IGltYWdlLlxuICAgICAqIFRoYXQgaGFwcGVucyBiZWNhdXNlIGFsbCBtb2RhbCBpbWFnZXMgYXJlIHNob3duIGxpa2UgaW4gYSBjaXJjbGUuXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXROZXh0SW1hZ2U7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgdG8gZ2V0IHRoZSBwcmV2aW91cyBpbmRleC5cbiAgICAgKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGF0IGluZGV4IDAsIHdoZW4geW91IGNhbGwgcHJldiBhZ2FpbiwgeW91J2xsIGdvIHRvIHRoZSBsYXN0IGltYWdlLlxuICAgICAqIFRoYXQgaGFwcGVucyBiZWNhdXNlIGFsbCBtb2RhbCBpbWFnZXMgYXJlIHNob3duIGxpa2UgaW4gYSBjaXJjbGUuXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRQcmV2SW1hZ2U7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgdG8gYnVpbGQgYSB0ZXh0IGRlc2NyaXB0aW9uLlxuICAgICAqIFRoaXMgaXMgdXNlZCBhbHNvIHRvIGNyZWF0ZSB0aXRsZXMuXG4gICAgICogQHBhcmFtIEltYWdlIGltYWdlIHRvIGdldCBpdHMgZGVzY3JpcHRpb24uIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIHRoZSBjdXJyZW50IGltYWdlLlxuICAgICAqIEBwYXJhbSBib29sZWFuIGltYWdlV2l0aG91dERlc2NyaXB0aW9uIGlzIGEgYm9vbGVhbiB0aGF0IGl0J3MgdHJ1ZSBpZiB0aGUgaW1hZ2UgaGFzbid0IGEgJ21vZGFsJyBkZXNjcmlwdGlvbi5cbiAgICAgKiBAcmV0dXJucyBTdHJpbmcgZGVzY3JpcHRpb24gYnVpbHQgY29uY2F0ZW5hdGluZyBpbWFnZSBmaWVsZHMgd2l0aCBhIHNwZWNpZmljIGxvZ2ljLlxuICAgICAqL1xuICAgIHByaXZhdGUgYnVpbGRUZXh0RGVzY3JpcHRpb247XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgdG8gY2FsbCBoYW5kbGVCb3VuZGFyaWVzIHdoZW4gbmdPbkNoYW5nZXMgaXMgY2FsbGVkLlxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlSW5kZXhlcztcbn1cbiJdfQ==